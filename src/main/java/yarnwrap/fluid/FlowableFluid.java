package yarnwrap.fluid;
public class FlowableFluid { public net.minecraft.fluid.FlowableFluid wrapperContained; public FlowableFluid(net.minecraft.fluid.FlowableFluid wrapperContained) { this.wrapperContained = wrapperContained; }

public yarnwrap.state.property.IntProperty LEVEL() { return new yarnwrap.state.property.IntProperty(wrapperContained.LEVEL); }
// public void LEVEL(yarnwrap.state.property.IntProperty value) { wrapperContained.LEVEL = value.wrapperContained; }
public yarnwrap.state.property.BooleanProperty FALLING() { return new yarnwrap.state.property.BooleanProperty(wrapperContained.FALLING); }
// public void FALLING(yarnwrap.state.property.BooleanProperty value) { wrapperContained.FALLING = value.wrapperContained; }
// public java.util.Map shapeCache() { return wrapperContained.shapeCache; }
// public void shapeCache(java.util.Map value) { wrapperContained.shapeCache = value; }
// public void tryFlow(yarnwrap.world.World world,yarnwrap.util.math.BlockPos fluidPos,yarnwrap.fluid.FluidState state) { wrapperContained.tryFlow(world.wrapperContained,fluidPos.wrapperContained,state.wrapperContained); }
// public java.util.Map getSpread(yarnwrap.world.World world,yarnwrap.util.math.BlockPos pos,yarnwrap.block.BlockState state) { return wrapperContained.getSpread(world.wrapperContained,pos.wrapperContained,state.wrapperContained); }
// public yarnwrap.fluid.FluidState getUpdatedState(yarnwrap.world.World world,yarnwrap.util.math.BlockPos pos,yarnwrap.block.BlockState state) { return new yarnwrap.fluid.FluidState(wrapperContained.getUpdatedState(world.wrapperContained,pos.wrapperContained,state.wrapperContained)); }
public yarnwrap.fluid.FluidState getFlowing(int level,boolean falling) { return new yarnwrap.fluid.FluidState(wrapperContained.getFlowing(level,falling)); }
public yarnwrap.fluid.FluidState getStill(boolean falling) { return new yarnwrap.fluid.FluidState(wrapperContained.getStill(falling)); }
// public void beforeBreakingBlock(yarnwrap.world.WorldAccess world,yarnwrap.util.math.BlockPos pos,yarnwrap.block.BlockState state) { wrapperContained.beforeBreakingBlock(world.wrapperContained,pos.wrapperContained,state.wrapperContained); }
// public boolean receivesFlow(yarnwrap.util.math.Direction face,yarnwrap.world.BlockView world,yarnwrap.util.math.BlockPos pos,yarnwrap.block.BlockState state,yarnwrap.util.math.BlockPos fromPos,yarnwrap.block.BlockState fromState) { return wrapperContained.receivesFlow(face.wrapperContained,world.wrapperContained,pos.wrapperContained,state.wrapperContained,fromPos.wrapperContained,fromState.wrapperContained); }
// public int getMaxFlowDistance(yarnwrap.world.WorldView world) { return wrapperContained.getMaxFlowDistance(world.wrapperContained); }
// public boolean canFlowDownTo(yarnwrap.world.BlockView world,yarnwrap.fluid.Fluid fluid,yarnwrap.util.math.BlockPos pos,yarnwrap.block.BlockState state,yarnwrap.util.math.BlockPos fromPos,yarnwrap.block.BlockState fromState) { return wrapperContained.canFlowDownTo(world.wrapperContained,fluid.wrapperContained,pos.wrapperContained,state.wrapperContained,fromPos.wrapperContained,fromState.wrapperContained); }
// public boolean isInfinite(yarnwrap.world.World world) { return wrapperContained.isInfinite(world.wrapperContained); }
// public boolean canFlow(yarnwrap.world.BlockView world,yarnwrap.util.math.BlockPos fluidPos,yarnwrap.block.BlockState fluidBlockState,yarnwrap.util.math.Direction flowDirection,yarnwrap.util.math.BlockPos flowTo,yarnwrap.block.BlockState flowToBlockState,yarnwrap.fluid.FluidState fluidState,yarnwrap.fluid.Fluid fluid) { return wrapperContained.canFlow(world.wrapperContained,fluidPos.wrapperContained,fluidBlockState.wrapperContained,flowDirection.wrapperContained,flowTo.wrapperContained,flowToBlockState.wrapperContained,fluidState.wrapperContained,fluid.wrapperContained); }
// public int getLevelDecreasePerBlock(yarnwrap.world.WorldView world) { return wrapperContained.getLevelDecreasePerBlock(world.wrapperContained); }
// public int countNeighboringSources(yarnwrap.world.WorldView world,yarnwrap.util.math.BlockPos pos) { return wrapperContained.countNeighboringSources(world.wrapperContained,pos.wrapperContained); }
// public int getBlockStateLevel(yarnwrap.fluid.FluidState state) { return wrapperContained.getBlockStateLevel(state.wrapperContained); }
// public int getMinFlowDownDistance(yarnwrap.world.WorldView world,yarnwrap.util.math.BlockPos pos,int direction,yarnwrap.util.math.Direction state,yarnwrap.block.BlockState fromPos,yarnwrap.util.math.BlockPos stateCache,it.unimi.dsi.fastutil.shorts.Short2ObjectMap flowDownCache) { return wrapperContained.getMinFlowDownDistance(world.wrapperContained,pos.wrapperContained,direction,state.wrapperContained,fromPos.wrapperContained,stateCache.wrapperContained,flowDownCache); }
// public void flowToSides(yarnwrap.world.World world,yarnwrap.util.math.BlockPos pos,yarnwrap.fluid.FluidState fluidState,yarnwrap.block.BlockState blockState) { wrapperContained.flowToSides(world.wrapperContained,pos.wrapperContained,fluidState.wrapperContained,blockState.wrapperContained); }
// public void flow(yarnwrap.world.WorldAccess world,yarnwrap.util.math.BlockPos pos,yarnwrap.block.BlockState state,yarnwrap.util.math.Direction direction,yarnwrap.fluid.FluidState fluidState) { wrapperContained.flow(world.wrapperContained,pos.wrapperContained,state.wrapperContained,direction.wrapperContained,fluidState.wrapperContained); }
// public boolean canFlowThrough(yarnwrap.world.BlockView world,yarnwrap.fluid.Fluid fluid,yarnwrap.util.math.BlockPos pos,yarnwrap.block.BlockState state,yarnwrap.util.math.Direction face,yarnwrap.util.math.BlockPos fromPos,yarnwrap.block.BlockState fromState,yarnwrap.fluid.FluidState fluidState) { return wrapperContained.canFlowThrough(world.wrapperContained,fluid.wrapperContained,pos.wrapperContained,state.wrapperContained,face.wrapperContained,fromPos.wrapperContained,fromState.wrapperContained,fluidState.wrapperContained); }
// public short packXZOffset(yarnwrap.util.math.BlockPos from,yarnwrap.util.math.BlockPos to) { return wrapperContained.packXZOffset(from.wrapperContained,to.wrapperContained); }
// public boolean isEmptyOrThis(yarnwrap.fluid.FluidState state) { return wrapperContained.isEmptyOrThis(state.wrapperContained); }
// public boolean isFlowBlocked(yarnwrap.world.BlockView world,yarnwrap.util.math.BlockPos pos,yarnwrap.util.math.Direction direction) { return wrapperContained.isFlowBlocked(world.wrapperContained,pos.wrapperContained,direction.wrapperContained); }
public yarnwrap.fluid.Fluid getFlowing() { return new yarnwrap.fluid.Fluid(wrapperContained.getFlowing()); }
public yarnwrap.fluid.Fluid getStill() { return new yarnwrap.fluid.Fluid(wrapperContained.getStill()); }
// public boolean isMatchingAndStill(yarnwrap.fluid.FluidState state) { return wrapperContained.isMatchingAndStill(state.wrapperContained); }
// public int getNextTickDelay(yarnwrap.world.World world,yarnwrap.util.math.BlockPos pos,yarnwrap.fluid.FluidState oldState,yarnwrap.fluid.FluidState newState) { return wrapperContained.getNextTickDelay(world.wrapperContained,pos.wrapperContained,oldState.wrapperContained,newState.wrapperContained); }
// public boolean canFill(yarnwrap.world.BlockView world,yarnwrap.util.math.BlockPos pos,yarnwrap.block.BlockState state,yarnwrap.fluid.Fluid fluid) { return wrapperContained.canFill(world.wrapperContained,pos.wrapperContained,state.wrapperContained,fluid.wrapperContained); }
// public boolean isFluidAboveEqual(yarnwrap.fluid.FluidState state,yarnwrap.world.BlockView world,yarnwrap.util.math.BlockPos pos) { return wrapperContained.isFluidAboveEqual(state.wrapperContained,world.wrapperContained,pos.wrapperContained); }

}
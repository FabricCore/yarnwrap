package yarnwrap.client.render.model;
public class BakedQuadFactory { public net.minecraft.client.render.model.BakedQuadFactory wrapperContained; public BakedQuadFactory(net.minecraft.client.render.model.BakedQuadFactory wrapperContained) { this.wrapperContained = wrapperContained; }

// public float MAX_SCALE() { return wrapperContained.MAX_SCALE; }
// public float MIN_SCALE() { return wrapperContained.MIN_SCALE; }
public yarnwrap.client.render.model.json.ModelElementTexture uvLock(yarnwrap.client.render.model.json.ModelElementTexture texture,yarnwrap.util.math.Direction orientation,yarnwrap.util.math.AffineTransformation rotation) { return new yarnwrap.client.render.model.json.ModelElementTexture(wrapperContained.uvLock(texture.wrapperContained,orientation.wrapperContained,rotation.wrapperContained)); }
public void transformVertex(org.joml.Vector3f vertex,yarnwrap.util.math.AffineTransformation transformation) { wrapperContained.transformVertex(vertex,transformation.wrapperContained); }
// public int[] packVertexData(yarnwrap.client.render.model.json.ModelElementTexture texture,yarnwrap.client.texture.Sprite sprite,yarnwrap.util.math.Direction direction,float positionMatrix,net.minecraft.util.math.AffineTransformation[] orientation,yarnwrap.client.render.model.json.ModelRotation rotation,boolean shaded) { return wrapperContained.packVertexData(texture.wrapperContained,sprite.wrapperContained,direction.wrapperContained,positionMatrix,orientation,rotation.wrapperContained,shaded); }
// public float[] getPositionMatrix(org.joml.Vector3f from,org.joml.Vector3f to) { return wrapperContained.getPositionMatrix(from,to); }
// public void packVertexData(int vertices,int cornerIndex,org.joml.Vector3f[] position,yarnwrap.client.texture.Sprite sprite,yarnwrap.client.render.model.json.ModelElementTexture modelElementTexture) { wrapperContained.packVertexData(vertices,cornerIndex,position,sprite.wrapperContained,modelElementTexture.wrapperContained); }
// public void packVertexData(int vertices,int cornerIndex,net.minecraft.util.math.Direction[] direction,yarnwrap.client.render.model.json.ModelElementTexture texture,float positionMatrix,net.minecraft.client.texture.Sprite[] sprite,yarnwrap.util.math.AffineTransformation orientation,yarnwrap.client.render.model.json.ModelRotation rotation,boolean shaded) { wrapperContained.packVertexData(vertices,cornerIndex,direction,texture.wrapperContained,positionMatrix,sprite,orientation.wrapperContained,rotation.wrapperContained,shaded); }
// public void encodeDirection(int rotationMatrix,net.minecraft.util.math.Direction[] direction) { wrapperContained.encodeDirection(rotationMatrix,direction); }
// public void rotateVertex(org.joml.Vector3f vector,yarnwrap.client.render.model.json.ModelRotation rotation) { wrapperContained.rotateVertex(vector,rotation.wrapperContained); }
// public void transformVertex(org.joml.Vector3f vertex,org.joml.Vector3f origin,org.joml.Matrix4f transformationMatrix,org.joml.Vector3f scale) { wrapperContained.transformVertex(vertex,origin,transformationMatrix,scale); }
// public yarnwrap.util.math.Direction decodeDirection(int rotationMatrix) { return new yarnwrap.util.math.Direction(wrapperContained.decodeDirection(rotationMatrix)); }
public yarnwrap.client.render.model.BakedQuad bake(org.joml.Vector3f from,org.joml.Vector3f to,yarnwrap.client.render.model.json.ModelElementFace face,yarnwrap.client.texture.Sprite texture,yarnwrap.util.math.Direction side,yarnwrap.client.render.model.ModelBakeSettings settings,yarnwrap.client.render.model.json.ModelRotation rotation,boolean shade) { return new yarnwrap.client.render.model.BakedQuad(wrapperContained.bake(from,to,face.wrapperContained,texture.wrapperContained,side.wrapperContained,settings.wrapperContained,rotation.wrapperContained,shade)); }

}